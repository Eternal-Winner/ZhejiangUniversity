# 05-树9 Huffman Codes

![Untitled](05-%E6%A0%919%20Huffman%20Codes%20f80812ef8fa949a08e5c5ebaf345d220/Untitled.png)

- Input Specification
    - Each input file contains one test case. For each case, the first line gives an integer *N*
     (2≤*N*≤63), then followed by a line that contains all the *N* distinct characters and their frequencies in the following format:
        
        ```cpp
        c[1] f[1] c[2] f[2] ... c[N] f[N]
        ```
        
    - where `c[i]` is a character chosen from {'0' - '9', 'a' - 'z', 'A' - 'Z', '_'}, and `f[i]`
     is the frequency of `c[i]`and is an integer no more than 1000. The next line gives a positive integer *M*(≤1000), then followed by *M* student submissions. Each student submission consists of *N* lines, each in the format:
    
    ```cpp
    c[i] code[i]
    ```
    
    where `c[i]`is the `i`-th character and `code[i]` is an non-empty string of no more than 63 '0's and '1's.
    
- Output Specification
    
    For each test case, print in each line either "Yes" if the student's submission is correct, or "No" if not. Note: The optimal solution is not necessarily generated by Huffman algorithm. Any prefix code with code length being optimal is considered correct.
    

---

- Sample Input
    
    ```cpp
    7
    A 1 B 1 C 1 D 3 E 3 F 6 G 6
    4
    A 00000
    B 00001
    C 0001
    D 001
    E 01
    F 10
    G 11
    A 01010
    B 01011
    C 0100
    D 011
    E 10
    F 11
    G 00
    A 000
    B 001
    C 010
    D 011
    E 100
    F 101
    G 110
    A 00000
    B 00001
    C 0001
    D 001
    E 00
    F 10
    G 11	
    ```
    
- Sample Output
    
    ```cpp
    Yes
    Yes
    No
    No
    ```
    

---

```cpp
7
A 1 B 1 C 1 D 3 E 3 F 6 G 6
1
A 00000
B 00001
C 0001
D 001
E 00
F 10
G 11
```

---

## 总结

- 最大的问题就是抽像，对于一个模型难以抽象成数据的形式，导致难以对题目进行处理，比如对于判断学生提交码该如何抽像成HuffmanTree，又该如何判断此类。
- 对于数据的接口难以处理，在本题中，数据结构HuffumanTree和Heap的接口处理一直处理不当，后面出查资料
    
    ```cpp
    typedef struct TreeNode *HuffmanTree;
    struct TreeNode{
        int Weight;
        HuffmanTree Left;
        HuffmanTree Right;
    };
    
    typedef struct HeapStruct* MinHeap;
    struct HeapStruct{
        HuffmanTree Element[MHSize];
        int Size;
    };
    
    void Insert(MinHeap H,HuffmanTree T)
    {
        int i;
        i = ++H->Size;  //Inserting i into the last element for H;
        for(;H->Element[i/2]->Weight > T->Weight ; i /= 2){
                H->Element[i] = H->Element[i/2];
        }
        H->Element[i] = T;
    }
    
    HuffmanTree Delete(MinHeap H)
    {
        int Parent , Child;
        HuffmanTree MinItem, temp;
        if(!H) cout << "Empty";
    
        MinItem = H->Element[1];
    
        temp = H->Element[H->Size--];
    
        for(Parent = 1; Parent * 2 <= H->Size; Parent = Child){
            Child = Parent * 2;
            if((Child != H->Size) && (H->Element[Child]->Weight > H->Element[Child + 1]->Weight)) // wrong <
                Child++;
            if(temp->Weight <= H->Element[Child]->Weight) break; //wrong <
            else{
                H->Element[Parent] = H->Element[Child];
            }
        }
        H->Element[Parent] = temp;
    
        return MinItem;
    }
    
    HuffmanTree buildHuffman(MinHeap H)
    {
        int i; HuffmanTree T;
        int size = H->Size;
        for(i = 1; i < size; i++){
            T = creatHuffman(); //Miss this statement will deduce all node same;
            T->Left = Delete(H);
    
            T->Right = Delete(H);
    
            T->Weight = T->Right->Weight + T->Left->Weight;
    
            Insert(H,T);
        }
    
        T = Delete(H);
    
        return T;
    }
    ```
    
- 细节把控问题严重
    
    ```cpp
    bool Judge(void)
    {
    //  ***HuffmanTree T = new TreeNode; every step following T->next;
    /*
    此处直接利用T对后续进行判断，导致对每串字符进行判断是都是承接上次树的结尾，
    而不能解决当前huffmanCode是否是此前huffmanCode的前缀码，当前码是否在叶节点上的问题；
    只能处理length的问题。
    */***
        HuffmanTree headT = new TreeNode, curT;
    
        for(int i = 0; i < nInteger; i++){
    //        if(strlen(str) >= nInteger) Tag = false;
            frequency = N[i];//
            cin >> c >> str;
            curT = headT;
    
            for(j = 0; c != C[j]; j++);
            frequency = N[i];
    
            for (j = 0; j < strlen(str); ++j) {
                if(str[j] == '0'){
                    if(!curT->Left)//The left child-tree is empty
                        curT->Left = creatHuffman();
                    curT = curT->Left;
                }
                else if(str[j] == '1') {//The right chile-tree is empty
                    if(!curT->Right)
                        curT->Right = creatHuffman();
                    curT = curT->Right;
                }
    
                if(curT->Weight) {
                    Tag = false;
    //                return Tag;
                }
            }
            if(curT->Left || curT->Right)  {
                Tag = false;
    //            return Tag;
            }
            else
                curT->Weight = frequency;
            length += (strlen(str) * curT->Weight);
        }
        if(length != rightLength)
            Tag = false;
    
        return Tag;
    }
    ```